
== 高级 Advanced

下面的章节介绍了Activiti的高级用例，超过了传统的BPMN 2.0流程的执行。因此，要理解这里的材料需要对Activiti足够熟练与精通。

[[advanced_parseHandlers]]

=== 异步与作业执行器 Async and job executor

从5.17.0版本开始，Activiti在已有的作业执行器之外，还提供了异步执行器。在Activiti引擎中，两个执行器都处理定时器与异步作业，因此只能启用一个执行器。这个章节将介绍异步执行器与作业执行器的区别，以及为什么我们推荐使用异步执行器。请注意默认情况下Activiti使用已有的作业执行器，因为我们不希望没有进行明确的配置就启用异步执行器。

==== 异步执行器的设计 Async executor design

异步执行器包含了一个用于执行定时器与异步作业的线程池。当启用时，引擎将会使用已经持久化的异步作业实体调用异步执行器，然后线程池将异步地执行该作业。这是与老的作业执行器的主要区别，因为在这种情况下，异步作业已被持久化，而作业执行器将会轮询数据库获取新作业。如果找到了一个作业，将锁定并执行它，这意味着大量额外的数据库通信。异步执行器会直接执行异步作业，而不会先轮询数据库。如果异步作业是一个排他作业，异步执行器将首先锁定流程实例的执行，如果成功将执行作业，并解锁流程实例执行。如果锁定流程实例失败，则会重试。

对于定时器作业，逻辑与异步作业不同，异步与作业执行器的实现相近。异步执行器将轮询数据库中将要到时执行的定时器作业。然后会锁定并执行作业。

==== 作业执行器的设计 Job executor design

作业执行器也包含了一个用于执行定时器与异步作业的线程池。当启用时，作业执行器会轮询数据库，获取异步作业与定时器作业的到期时间。如果找到了一个作业，执行器将锁定并执行该作业，这意味着大量额外的数据库通信。相对应的，异步执行器会直接执行异步作业，而不会首先轮询数据库。

==== 异步执行器的优点 Advantages of the Async executor

* 更少的数据库查询，因为异步作业不通过轮询数据库就执行
* 对于非排他作业，不会再遇到OptimisticLockingExceptions（乐观锁异常）
* 排他作业现在锁定在流程实例级别，而不是在作业执行器中那样，使用笨重的逻辑查询排他作业。

==== 配置异步执行器 Async executor configuration

可以为异步执行器定义线程池大小与其他配置项。我们建议查看异步执行器的默认设置，核实其是否符合你的流程实例的要求。

要覆盖异步执行器的默认设置，需要在流程引擎配置中注入一个新的bean，像是：

[source,xml,linenums]
----
<property name="asyncExecutor" ref="asyncExecutor" />
----

可以覆盖默认的异步执行器，以覆盖默认设置，但是当然也可以从DefaultAsyncJobExecutor类扩展。下面列出的配置中，DefaultAsyncJobExecutor的参数使用了新的值：

[source,xml,linenums]
----
<bean id="asyncExecutor" class="org.activiti.engine.impl.asyncexecutor.DefaultAsyncJobExecutor">
    <property name="corePoolSize" value="10" />
    <property name="maxPoolSize" value="50" />
    <property name="keepAliveTime" value="3000" />
    <property name="queueSize" value="200" />
    <property name="maxTimerJobsPerAcquisition" value="2" />
    <property name="maxAsyncJobsDuePerAcquisition" value="2" />
    <property name="defaultAsyncJobAcquireWaitTimeInMillis" value="1000" />
    <property name="defaultTimerJobAcquireWaitTimeInMillis" value="1000" />
    <property name="timerLockTimeInMillis" value="60000" />
    <property name="asyncJobLockTimeInMillis" value="60000" />
</bean>
----

.异步执行器配置选项
[options="header"]
|===============
|名字|默认值|描述
|corePoolSize|2|线程池中为执行作业保留的最小线程数量。
|maxPoolSize|10|线程池中为执行作业保留的最大线程数量。
|keepAliveTime|5000|在销毁作业执行所用的线程前，需要保持活动的时间（以毫秒计）。默认设置为5000。设置为0非默认值会消耗资源，但在有大量执行作业的时候，可以避免总是创建新线程。

|queueSize|100|放置待执行作业的队列的大小。
|maxTimerJobsPerAcquisition|1|在一次查询中获取的将到期定时器作业的数量。
|maxAsyncJobsDuePerAcquisition|1|在一次数据库查询中获取的异步作业的数量。
|defaultAsyncJobAcquireWaitTimeInMillis|10000|在执行异步作业查询之间等待的时间，以毫秒计。
|defaultTimerJobAcquireWaitTimeInMillis|10000|在执行将到期定时器作业查询之间等待的时间，以毫秒计。
|timerLockTimeInMillis|300000|在重试之前，定时器作业锁定的时间，以毫秒计。在该时间之后，Activiti引擎会视为定时器作业已经失败，并将重试。

|asyncJobLockTimeInMillis|300000|在重试之前，异步作业锁定的时间，以毫秒计。在该时间之后，Activiti引擎会视为异步作业已经失败，并将重试。

|===============

=== 深入流程解析 Hooking into process parsing

一个BPMN 2.0 XML需要解析为Activiti的内部模型，才能在Activiti引擎中执行。解析发生在部署流程时；或没有在内存中找到流程的时候，这时将会从数据库获取XML。

对于每一个流程，++BpmnParser++类都会创建一个新的++BpmnParser++实例。这个实例会用作所有在解析时要做的事情的容器。解析本身很简单：对于每一个BPMN 2.0元素，引擎中都有一个对应的++org.activiti.engine.parse.BpmnParseHandler++的实例。因此，解析器会将一个BPMN 2.0元素类映射至一个++BpmnParseHandler++实例。默认情况下，Activiti使用++BpmnParseHandler++实例处理所有支持的元素，并用其为流程的步骤附加执行监听器，以创建历史。

可以在Activiti引擎中添加++org.activiti.engine.parse.BpmnParseHandler++的自定义实例。常见用例时，例如为特定步骤添加执行监听器，用于向某个事件处理队列触发事件。Activiti内部使用这种方式处理历史。要添加这种自定义处理器，需要调整Activiti配置：

[source,xml,linenums]
----
<property name="preBpmnParseHandlers">
  <list>
    <bean class="org.activiti.parsing.MyFirstBpmnParseHandler" />
  </list>
</property>

<property name="postBpmnParseHandlers">
  <list>
    <bean class="org.activiti.parsing.MySecondBpmnParseHandler" />
    <bean class="org.activiti.parsing.MyThirdBpmnParseHandler" />
  </list>
</property>
----

在++preBpmnParseHandlers++参数中配置的++BpmnParseHandler++实例的列表将添加在任何默认处理器之前。类似的，++postBpmnParseHandlers++中的将添加在之后。在顺序会影响自定义解析处理器中包含的逻辑时很重要。

++org.activiti.engine.parse.BpmnParseHandler++是一个简单的接口：

[source,java,linenums]
----
public interface BpmnParseHandler {

  Collection<Class>? extends BaseElement>> getHandledTypes();

  void parse(BpmnParse bpmnParse, BaseElement element);

}
----

++getHandledTypes()++方法返回该解析器处理的所有类型的集合。可用的类型是++BaseElement++的子类，通过集合的泛型指定。也可以扩展++AbstractBpmnParseHandler++类，并覆盖++getHandledType()+方法，它只返回一个类而不是一个集合。这个类也包含了一些默认解析处理器共享的辅助方法。当解析器遇到任何该方法的返回类型时，将调用++BpmnParseHandler++实例。在下面的例子里，当遇到BPMN 2.0 XML中包含的流程时，将会执行++executeParse++方法（这是一个类型转换方法，取代了++BpmnParseHandler++接口中的普通++parse++方法）中的逻辑。

[source,java,linenums]
----
public class TestBPMNParseHandler extends AbstractBpmnParseHandler<Process> {

  protected Class<? extends BaseElement> getHandledType() {
    return Process.class;
  }

  protected void executeParse(BpmnParse bpmnParse, Process element) {
     ..
  }

}
----

**重要提示：**当撰写自定义解析处理器时，不要使用任何用于解析BPMN 2.0结构的内部类。这将导致很难查找bug。实现一个自定义处理器安全的做法是实现__BpmnParseHandler__接口，或扩展内部抽象类__org.activiti.engine.impl.bpmn.parser.handler.AbstractBpmnParseHandler__。

可以（但不常见）替换默认的++BpmnParseHandler++实例，该实例用于将BPMN 2.0元素解析为Activiti内部模型。可以通过下面的代码片段实现：

[source,xml,linenums]
----
<property name="customDefaultBpmnParseHandlers">
  <list>
    ...
  </list>
</property>
----

简单的例子是用于将所有服务任务都强制异步执行：

[source,java,linenums]
----
public class CustomUserTaskBpmnParseHandler extends ServiceTaskParseHandler {

  protected void executeParse(BpmnParse bpmnParse, ServiceTask serviceTask) {

    // 进行常规操作 Do the regular stuff
    super.executeParse(bpmnParse, serviceTask);

    // 保证异步 Make always async
    ActivityImpl activity = findActivity(bpmnParse, serviceTask.getId());
    activity.setAsync(true);
  }

}
----


[[advanced.uuid.generator]]


=== 高并发下使用的UUID id生成器 UUID id generator for high concurrency

在某些（非常）高并发负载的情况下，默认的id生成器可能会由于不能足够快地获取新的id块而产生异常。每一个流程引擎都有一个id生成器。默认的id生成器在数据库中保留一个块的id，这样其他引擎就不能使用同一个块中的id。在引擎操作时，当默认的id生成器发现id块已经用完，就会启动一个新的事务，来获取一个新的块。在（非常）有限的使用场景下，当负载非常高时可能导致问题。对于大多数用例来说，默认的id生成器已经足够使用了。默认的++org.activiti.engine.impl.db.DbIdGenerator++也有一个++idBlockSize++参数，用于配置保留的id块的大小，可以调整获取id的行为。

默认的id生成器的替代品是++org.activiti.engine.impl.persistence.StrongUuidGenerator++，它会在本地生成一个唯一的link:$$http://en.wikipedia.org/wiki/Universally_unique_identifier$$[UUID]，并将其用作所有实体的标识符。因为UUID不需要访问数据库就能生成，因此在非常高并发的使用场景下更合适。请注意取决于机器，性能可能与默认的id生成器不同（更好更坏都有可能）。

可以在activiti配置中，像下面这样配置UUID生成器：

[source,xml,linenums]
----
<property name="idGenerator">
    <bean class="org.activiti.engine.impl.persistence.StrongUuidGenerator" />
</property>
----

使用UUID id生成器使用下列额外依赖：

[source,xml,linenums]
----
 <dependency>
    <groupId>com.fasterxml.uuid</groupId>
    <artifactId>java-uuid-generator</artifactId>
    <version>3.1.3</version>
</dependency>
----


[[advanced.tenancy]]


=== 多租户 Multitenancy

总的来说，多租户是一个软件为多个不同组织提供服务的概念。其核心是数据是隔离的，一个组织不能看到其他组织的数据。在这个上下文中，一个这种组织（或部门、团队……）被称为一个__租户（tenant）__。

请注意它与多实例安装方式有本质区别，其中多实例安装是指每一个组织都分别运行一个Activiti流程引擎实例（并使用不同的数据库账户）。尽管Activiti比较轻量级，运行一个流程引擎实例不会花费太多资源，但仍然增加了复杂性与维护量。但是，在某些用力下可能是正确的解决方案。

Activiti中的多租户主要围绕着隔离数据实现。要注意__Activiti并不强制多租户规则__。这意味着当查询与使用数据时并不会验证进行操作的用户属于正确的租户。这应该在调用Activiti引擎的层次实现。Activiti确保可以存储租户信息，并在获取流程数据时使用。

在Activiti流程引擎中部署流程定义时，可以传递一个__租户标识符（tenant identifier）__。这是一个字符串（例如一个UUID，部门id，等等……），限制为256个字符长，唯一标识租户：

[source,java,linenums]
----
repositoryService.createDeployment()
            .addClassPathResource(...)
            .tenantId("myTenantId")
            .deploy();
----

在部署时传递一个租户id带有下列含义：

* 部署中包含的所有流程定义都将从该部署集成租户标识符。
* 从这些流程定义启动的所有流程实例都将从流程定义继承租户标识符。
* 在执行流程实例时，运行时创建的所有任务都将从流程实例继承租户标识符。独立任务也可以有租户标识符。
* 执行流程实例时创建的所有执行都将从流程实例继承租户标识符。
* 触发一个信号抛出事件（在流程内或通过API）时可以提供一个租户标识符。这个信号将只在该租户的上下文中执行：也就是说，如果有多个使用相同名字的信号捕获事件，只会调用带有正确租户标识符的事件。
* 所有作业（定时器与异步延续）要么从流程定义（例如定时器启动事件），要么从流程实例（运行时创建的作业，例如异步延续）继承租户标识符。这可以用于在自定义作业执行器中为部分租户设置优先级。
* 所有历史实体（历史流程实例、任务与活动）都从其对应的运行时对象继承租户标识符。
* 另外，模型也可以有租户标识符（模型在例如Activiti Modeler存储BPMN 2.0模型的时候使用）。

为了实际使用流程数据上的租户标识符，所有查询API都可以通过租户过滤。例如（也可以使用其他实体的对应查询实现替换）：

[source,java,linenums]
----
runtimeService.createProcessInstanceQuery()
    .processInstanceTenantId("myTenantId")
    .processDefinitionKey("myProcessDefinitionKey")
    .variableValueEquals("myVar", "someValue")
    .list()
----

查询API也可以使用__like__语义通过租户标识符过滤，也可以过滤掉没有租户标识符的实体。

**重要的实现细节：**由于数据库的原因（更确切地说，唯一约束的null处理），__默认的__代表__没有租户__的租户标识符为**空字符串**。（流程定义key，流程定义版本，租户标识符）的组合需要是唯一的（并且通过数据库约束检查）。也请注意租户标识符不能设置为null，不然会影响查询，因为某些数据库（Oracle）将空字符串当做null值（这就是为什么__.withoutTenantId__查询不检查空字符串还是null）。这意味着同一个流程定义（有相同的流程定义key）可以为多个租户部署，每一个租户都有他们自己的版本。未使用租户时不会影响使用。

**请注意上面所说都不与在集群中运行多个Activiti实例冲突。**

[试验性] 可以调用__repositoryService__的__changeDeploymentTenantId(String deploymentId, String newTenantId)__方法修改租户标识符。这将修改每一处之前继承的租户标识符。在从非多租户环境迁移至多租户配置时很有用。查看该方法的Javadoc了解更多细节信息。

[[advanced.custom.sql.queries]]


=== Execute custom SQL

The Activiti API allows for interacting with the database using a high level API. For example, for retrieving data the Query API and the Native Query API are powerful in its usage. However, for some use cases they might not be flexible enough. The following section describes how a completely custom SQL statement (select, insert, update and delete are possible) can be executed against the Activiti data store, but completely within the configured Process Engine (and thus levering the transaction setup for example).

To define custom SQL statements, the Activiti engine leverages the capabilities of its underlying framework, MyBatis. More info can be read  link:$$http://mybatis.github.io/mybatis-3/java-api.html$$[in the MyBatis user guide].

==== Annotation based Mapped Statements

The first thing to do when using Annotation based Mapped Statements, is to create a MyBatis mapper class. For example, suppose that for some use case not the whole task data is needed, but only a small subset of it. A Mapper that could do this, looks as follows:

[source,java,linenums]
----
public interface MyTestMapper {

    @Select("SELECT ID_ as id, NAME_ as name, CREATE_TIME_ as createTime FROM ACT_RU_TASK")
    List<Map<String, Object>> selectTasks();

}
----


This mapper must be provided to the Process Engine configuration as follows:

[source,xml,linenums]
----
...
<property name="customMybatisMappers">
  <set>
    <value>org.activiti.standalone.cfg.MyTestMapper</value>
  </set>
</property>
...
----

Notice that this is an interface. The underlying MyBatis framework will make an instance of it that can be used at runtime. Also notice that the return value of the method is not typed, but a list of maps (which corresponds to the list of rows with column values). Typing is possible with the MyBatis mappers if wanted.

To execute the query above, the _managementService.executeCustomSql_ method must be used. This method takes in a _CustomSqlExecution_ instance. This is a wrapper that hides the internal bits of the engine otherwise needed to make it work.


Unfortunately, Java generics make it a bit less readable than it could have been. The two generic types below are the mapper class and the return type class. However, the actual logic is simply to call the mapper method and return its results (if applicable).

[source,java,linenums]
----
CustomSqlExecution<MyTestMapper, List<Map<String, Object>>> customSqlExecution =
          new AbstractCustomSqlExecution<MyTestMapper, List<Map<String, Object>>>(MyTestMapper.class) {

  public List<Map<String, Object>> execute(MyTestMapper customMapper) {
    return customMapper.selectTasks();
  }

};

List<Map<String, Object>> results = managementService.executeCustomSql(customSqlExecution);
----


The Map entries in the list above will only contain _id, name and create time_ in this case and not the full task object.

Any SQL is possible when using the approach above. Another more complex example:

[source,java,linenums]
----
    @Select({
        "SELECT task.ID_ as taskId, variable.LONG_ as variableValue FROM ACT_RU_VARIABLE variable",
        "inner join ACT_RU_TASK task on variable.TASK_ID_ = task.ID_",
        "where variable.NAME_ = #{variableName}"
    })
    List<Map<String, Object>> selectTaskWithSpecificVariable(String variableName);
----

Using this method, the task table will be joined with the variables table. Only where the variable has a certain name is retained, and the task id and the corresponding numerical value is returned.

For a working example on using Annotation based Mapped Statements check the unit test _org.activiti.standalone.cfg.CustomMybatisMapperTest_ and other classes and resources in folders src/test/java/org/activiti/standalone/cfg/ and src/test/resources/org/activiti/standalone/cfg/


==== XML based Mapped Statements

When using XML based Mapped Statements, statements are defined in XML files. For the use case where not the whole task data is needed, but only a small subset of it. The XML file can look as follows:

[source,xml,linenums]
----
<mapper namespace="org.activiti.standalone.cfg.TaskMapper">

  <resultMap id="customTaskResultMap" type="org.activiti.standalone.cfg.CustomTask">
    <id property="id" column="ID_" jdbcType="VARCHAR"/>
    <result property="name" column="NAME_" jdbcType="VARCHAR"/>
    <result property="createTime" column="CREATE_TIME_" jdbcType="TIMESTAMP" />
  </resultMap>

  <select id="selectCustomTaskList" resultMap="customTaskResultMap">
    select RES.ID_, RES.NAME_, RES.CREATE_TIME_ from ACT_RU_TASK RES
  </select>

</mapper>
----

Results are mapped to instances of _org.activiti.standalone.cfg.CustomTask_ class which can look as follows:

[source,java,linenums]
----
public class CustomTask {

  protected String id;
  protected String name;
  protected Date createTime;

  public String getId() {
    return id;
  }
  public String getName() {
    return name;
  }
  public Date getCreateTime() {
    return createTime;
  }
}
----

Mapper XML files must be provided to the Process Engine configuration as follows:

[source,xml,linenums]
----
...
<property name="customMybatisXMLMappers">
  <set>
    <value>org/activiti/standalone/cfg/custom-mappers/CustomTaskMapper.xml</value>
  </set>
</property>
...
----

The statement can be executed as follows:
[source,java,linenums]
----
List<CustomTask> tasks = managementService.executeCommand(new Command<List<CustomTask>>() {

      @SuppressWarnings("unchecked")
      @Override
      public List<CustomTask> execute(CommandContext commandContext) {
        return (List<CustomTask>) commandContext.getDbSqlSession().selectList("selectCustomTaskList");
      }
    });
----

For uses cases that require more complicated statements, XML Mapped Statements can be helpful. Since Activiti uses XML Mapped Statements internally, it's possible to make use of the underlying capabilities.

Suppose that for some use case the ability to query attachments data is required based on id, name, type, userId, etc! To fulfill the use case a query class _AttachmentQuery_ that extends  _org.activiti.engine.impl.AbstractQuery_ can be created as follows:

[source,java,linenums]
----
public class AttachmentQuery extends AbstractQuery<AttachmentQuery, Attachment> {

  protected String attachmentId;
  protected String attachmentName;
  protected String attachmentType;
  protected String userId;

  public AttachmentQuery(ManagementService managementService) {
    super(managementService);
  }

  public AttachmentQuery attachmentId(String attachmentId){
    this.attachmentId = attachmentId;
    return this;
  }

  public AttachmentQuery attachmentName(String attachmentName){
    this.attachmentName = attachmentName;
    return this;
  }

  public AttachmentQuery attachmentType(String attachmentType){
    this.attachmentType = attachmentType;
    return this;
  }

  public AttachmentQuery userId(String userId){
    this.userId = userId;
    return this;
  }

  @Override
  public long executeCount(CommandContext commandContext) {
    return (Long) commandContext.getDbSqlSession()
                   .selectOne("selectAttachmentCountByQueryCriteria", this);
  }

  @Override
  public List<Attachment> executeList(CommandContext commandContext, Page page) {
    return commandContext.getDbSqlSession()
            .selectList("selectAttachmentByQueryCriteria", this);
  }
----

Note that when extending _AbstractQuery_ extended classes should pass an instance of _ManagementService_ to super constructor and methods _executeCount_ and _executeList_ need to be implemented to call the mapped statements.

The XML file containing the mapped statements can look as follows:

[source,xml,linenums]
----
<mapper namespace="org.activiti.standalone.cfg.AttachmentMapper">

  <select id="selectAttachmentCountByQueryCriteria" parameterType="org.activiti.standalone.cfg.AttachmentQuery" resultType="long">
    select count(distinct RES.ID_)
    <include refid="selectAttachmentByQueryCriteriaSql"/>
  </select>

  <select id="selectAttachmentByQueryCriteria" parameterType="org.activiti.standalone.cfg.AttachmentQuery" resultMap="org.activiti.engine.impl.persistence.entity.AttachmentEntity.attachmentResultMap">
    ${limitBefore}
    select distinct RES.* ${limitBetween}
    <include refid="selectAttachmentByQueryCriteriaSql"/>
    ${orderBy}
    ${limitAfter}
  </select>

  <sql id="selectAttachmentByQueryCriteriaSql">
  from ${prefix}ACT_HI_ATTACHMENT RES
  <where>
   <if test="attachmentId != null">
     RES.ID_ = #{attachmentId}
   </if>
   <if test="attachmentName != null">
     and RES.NAME_ = #{attachmentName}
   </if>
   <if test="attachmentType != null">
     and RES.TYPE_ = #{attachmentType}
   </if>
   <if test="userId != null">
     and RES.USER_ID_ = #{userId}
   </if>
  </where>
  </sql>
</mapper>
----

Capabilities such as pagination, ordering, table name prefixing are available and can be used in the statements (since the parameterType is a subclass of _AbstractQuery_). Note that to map results the predefined _org.activiti.engine.impl.persistence.entity.AttachmentEntity.attachmentResultMap_ resultMap can be used.

Finally, the _AttachmentQuery_ can be used as follows:

[source,java,linenums]
----
....
// Get the total number of attachments
long count = new AttachmentQuery(managementService).count();

// Get attachment with id 10025
Attachment attachment = new AttachmentQuery(managementService).attachmentId("10025").singleResult();

// Get first 10 attachments
List<Attachment> attachments = new AttachmentQuery(managementService).listPage(0, 10);

// Get all attachments uploaded by user kermit
attachments = new AttachmentQuery(managementService).userId("kermit").list();
....
----

For working examples on using XML Mapped Statements check the unit test _org.activiti.standalone.cfg.CustomMybatisXMLMapperTest_ and other classes and resources in folders src/test/java/org/activiti/standalone/cfg/ and src/test/resources/org/activiti/standalone/cfg/


[[advanced.process.engine.configurators]]


=== Advanced Process Engine configuration with a ProcessEngineConfigurator

An advanced way of hooking into the process engine configuration is through the use of a  _ProcessEngineConfigurator_. The idea is that an implementation of the  _org.activiti.engine.cfg.ProcessEngineConfigurator_ interface is created and injected  into the process engine configuration:

[source,xml,linenums]
----
<bean id="processEngineConfiguration" class="...SomeProcessEngineConfigurationClass">

    ...

    <property name="configurators">
        <list>
            <bean class="com.mycompany.MyConfigurator">
                ...
            </bean>
        </list>
    </property>

    ...

</bean>
----


There are two methods required to implement this interface. The _configure_ method, which gets a _ProcessEngineConfiguration_ instance as parameter. The custom configuration can be added this way, and this method will guaranteed be called *before the process engine is created, but after all default configuration has been done*. The other method is the _getPriority_ method, which allows for ordering the configurators in the case where some configurators are dependent on each other.

An example of such a configurator is the <<chapter_ldap,LDAP integration>>, where the  configurator is used to replace the default user and group manager classes with one that is capable of handling an LDAP user store.	 So basically a configurator allows to change or tweak the process engine quite heavily and is meant for very advanced use cases. Another example is to swap the  process definition cache with a customized version:

[source,java,linenums]
----
public class ProcessDefinitionCacheConfigurator extends AbstractProcessEngineConfigurator {

    public void configure(ProcessEngineConfigurationImpl processEngineConfiguration) {
            MyCache myCache = new MyCache();
            processEngineConfiguration.setProcessDefinitionCache(enterpriseProcessDefinitionCache);
    }

}
----

Process Engine configurators can also be auto discovered from the classpath using the link:$$http://docs.oracle.com/javase/7/docs/api/java/util/ServiceLoader.html$$[ServiceLoader] approach. This means that a jar with the configurator implementation must be put on the classpath, containing a file in the _META-INF/services_ folder in the jar called *org.activiti.engine.cfg.ProcessEngineConfigurator*. The content of the file needs to be the fully qualified classname of the custom implementation. When the process engine is booted, the logging will show that these configurators are found:

----
INFO  org.activiti.engine.impl.cfg.ProcessEngineConfigurationImpl  - Found 1 auto-discoverable Process Engine Configurators
INFO  org.activiti.engine.impl.cfg.ProcessEngineConfigurationImpl  - Found 1 Process Engine Configurators in total:
INFO  org.activiti.engine.impl.cfg.ProcessEngineConfigurationImpl  - class org.activiti.MyCustomConfigurator
----

Note that this ServiceLoader approach might not work in certain environments. It can be  explicitly disabled using the _enableConfiguratorServiceLoader_ property of the ProcessEngineConfiguration (true by default).


[[advanced.task.query.switching]]


=== Advanced query API: seamless switching between runtime and historic task querying


One core component of any BPM user interface is the task list. Typically, end users work on open, runtime tasks, filtering  their inbox with various setting. Often also the historic tasks need to be displayed in those lists, with similar filtering. To make that code-wise easier, the _TaskQuery_ and _HistoricTaskInstanceQuery_ both have a shared parent interface, which contains all common operations (and most of the operations are common).

This common interface is the _org.activiti.engine.task.TaskInfoQuery_ class. Both _org.activiti.engine.task.Task_ and _org.activiti.engine.task.HistoricTaskInstance_  have a common superclass _org.activiti.engine.task.TaskInfo_ (with common properties) which is returned from e.g. the _list()_ method. However, Java generics are sometimes more harming than helping: if you want to use the _TaskInfoQuery_ type directly, it would look like this:

[source,java,linenums]
----
TaskInfoQuery<? extends TaskInfoQuery<?,?>, ? extends TaskInfo> taskInfoQuery
----

Ugh, Right. To 'solve' this, a _org.activiti.engine.task.TaskInfoQueryWrapper_ class that can be used to avoid the generics  (the following code could come from REST code that returns a task list where the user can switch between open and completed tasks):

[source,java,linenums]
----
TaskInfoQueryWrapper taskInfoQueryWrapper = null;
if (runtimeQuery) {
	taskInfoQueryWrapper = new TaskInfoQueryWrapper(taskService.createTaskQuery());
} else {
	taskInfoQueryWrapper = new TaskInfoQueryWrapper(historyService.createHistoricTaskInstanceQuery());
}

List<? extends TaskInfo> taskInfos = taskInfoQueryWrapper.getTaskInfoQuery().or()
	.taskNameLike("%k1%")
	.taskDueAfter(new Date(now.getTime() + (3 * 24L * 60L * 60L * 1000L)))
.endOr()
.list();
----


[[advanced.custom.session.manager]]


=== Custom identity management by overriding standard SessionFactory

If you do not want to use a full _ProcessEngineConfigurator_ implementation like in the  <<chapter_ldap,LDAP integration>>, but still want to plug in your custom identity management framework,  then you can also override the _SessionFactory_ classes directly in the _ProcessEngineConfiguration_.  In Spring this can be easily done by adding the following to the _ProcessEngineConfiguration_ bean definition:

[source,xml,linenums]
----
<bean id="processEngineConfiguration" class="...SomeProcessEngineConfigurationClass">

    ...

    <property name="customSessionFactories">
        <list>
            <bean class="com.mycompany.MyGroupManagerFactory"/>
            <bean class="com.mycompany.MyUserManagerFactory"/>
        </list>
    </property>

    ...

</bean>

----

The _MyGroupManagerFactory_ and _MyUserManagerFactory_ need to implement the _org.activiti.engine.impl.interceptor.SessionFactory_ interface. The call to _openSession()_ returns the custom class implementation that does the actual identity management. For groups this is a class that inherits from _org.activiti.engine.impl.persistence.entity.GroupEntityManager_ and for managing users it must inherit from _org.activiti.engine.impl.persistence.entity.UserEntityManager_. The following code sample contains a custom manager factory for groups:

[source,java,linenums]
----
package com.mycompany;

import org.activiti.engine.impl.interceptor.Session;
import org.activiti.engine.impl.interceptor.SessionFactory;
import org.activiti.engine.impl.persistence.entity.GroupIdentityManager;

public class MyGroupManagerFactory implements SessionFactory {

	@Override
	public Class<?> getSessionType() {
		return GroupIdentityManager.class;
	}

	@Override
	public Session openSession() {
		return new MyCompanyGroupManager();
	}

}
----

The _MyCompanyGroupManager_ created by the factory is doing the actual work. You do not need to override all members of _GroupEntityManager_ though, just the ones required for your use case. The following sample provides an indication of how this may look like (only a selection of members are shown):

[source,java,linenums]
----
public class MyCompanyGroupManager extends GroupEntityManager {

    private static Logger log = LoggerFactory.getLogger(MyCompanyGroupManager.class);

    @Override
    public List<Group> findGroupsByUser(String userId) {
        log.debug("findGroupByUser called with userId: " + userId);
        return super.findGroupsByUser(userId);
    }

    @Override
    public List<Group> findGroupByQueryCriteria(GroupQueryImpl query, Page page) {
        log.debug("findGroupByQueryCriteria called, query: " + query + " page: " + page);
        return super.findGroupByQueryCriteria(query, page);
    }

    @Override
    public long findGroupCountByQueryCriteria(GroupQueryImpl query) {
        log.debug("findGroupCountByQueryCriteria called, query: " + query);
        return super.findGroupCountByQueryCriteria(query);
    }

    @Override
    public Group createNewGroup(String groupId) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void deleteGroup(String groupId) {
        throw new UnsupportedOperationException();
    }
}
----

Add your own implementation in the appropriate methods to plugin your own identity management solution.
You have to figure out which member of the base class must be overridden. For example the following call:

[source,java,linenums]
----
long potentialOwners = identityService.createUserQuery().memberOfGroup("management").count();
----

leads to a call on the following member of the _UserIdentityManager_ interface:

[source,java,linenums]
----
List<User> findUserByQueryCriteria(UserQueryImpl query, Page page);
----


The code for the <<chapter_ldap,LDAP integration>> contains full examples of how to implement this. Check out the code on Github, specifically the following classes
          link:$$https://github.com/Activiti/Activiti/blob/master/modules/activiti-ldap/src/main/java/org/activiti/ldap/LDAPGroupManager.java$$[LDAPGroupManager] and
   link:$$https://github.com/Activiti/Activiti/blob/master/modules/activiti-ldap/src/main/java/org/activiti/ldap/LDAPUserManager.java$$[LDAPUserManager].


[[advanced.safe.bpmn.xml]]


=== Enable safe BPMN 2.0 xml


In most cases the BPMN 2.0 processes that are being deployed to the Activiti engine are under tight control of e.g. the development team. However, in some use cases it might be desirable to upload arbitrary BPMN 2.0 xml to the engine. In that case, take into consideration that a user with bad intentions can bring the server down as described link:$$http://www.jorambarrez.be/blog/2013/02/19/uploading-a-funny-xml-can-bring-down-your-server/$$[here].

To avoid the attacks described in the link above, a property _enableSafeBpmnXml_ can be set on the process engine configuration:

[source,xml,linenums]
----
<property name="enableSafeBpmnXml" value="true"/>
----

*By default this feature is disabled!* The reason for this is that it relies on  the availability of the link:$$http://download.java.net/jdk7/archive/b123/docs/api/javax/xml/transform/stax/StAXSource.html$$[StaxSource] class. Unfortunately, on some platforms (e.g. JDK 6, JBoss, etc.) this class is unavailable (due to older xml parser implementation) and thus the safe BPMN 2.0 xml feature cannot be enabled.

If the platform on which Activiti runs does support it, do enable this feature.


[[advanced.event.logging]]


=== Event logging (Experimental)

As of Activiti version 5.16, an (experimental) event logging mechanism has been introduced. The logging mechanism builds upon the general-purpose <<eventDispatcher,event mechanism of the Activiti engine>> and is disabled by default. The idea is that the events originating from the engine are caught, and a map containing all the event data (and some more) is created and provided to an _org.activiti.engine.impl.event.logger.EventFlusher_ which will flush this data to somewhere else. By default, simple database-backed event handlers/flusher is used, which serializes the said map to JSON using Jackson and stores it in the database as an _EventLogEntryEntity_ instance.  The table required for this database logging is  created by default (called __$$ACT_EVT_LOG$$__). This table can be deleted if the event logging is not used.

To enable the database logger:

[source,java,linenums]
----
processEngineConfiguration.setEnableDatabaseEventLogging(true);
----

or at runtime:

[source,xml,linenums]
----
databaseEventLogger = new EventLogger(processEngineConfiguration.getClock());
runtimeService.addEventListener(databaseEventLogger);
----

The EventLogger class can be subclassed. In particular, the _createEventFlusher()_ method needs to return an instance of the _org.activiti.engine.impl.event.logger.EventFlusher_ interface if the default database logging is not wanted. The _managementService.getEventLogEntries(startLogNr, size);_  can be used to retrieve the _EventLogEntryEntity_ instances through Activiti.

It is easy to see how this table data can now be used to feed the JSON into a big data NoSQL store such as MongoDB, Elastic Search, etc. It is also easy to see that the classes used here (org.activiti.engine.impl.event.logger.EventLogger/EventFlusher and many EventHandler classes) are pluggable and can be tweaked to your own use case (eg not storing the JSON in the database, but firing it straight onto a queue or big data store).

Note that this event logging mechanism is additional to the 'traditional' history manager of Activiti. Although all the data is in the database tables,
it is not optimized for querying nor for easy retrieval. The real use case is audit trailing and feeding it into a big data store.

=== Disabling bulk inserts

By default, the engine will group multiple insert statements for the same database table together in a _bulk insert_, thus improving performance. This has been tested and implemented for all supported databases.

However, it could be a specific version of a supported and tested database does not allow bulk inserts (we have for example a report for DB2 on z/OS, although DB2 in general works), the bulk insert can be disabled on the process engine configuration:

[source,xml,linenums]
----
<property name="bulkInsertEnabled" value="false" />
----

[[advancedSecureScripting]]
=== Secure Scripting

*Experimental*: the secure scripting feature has been added as part of the Activiti 5.21 release.

By default, when using a <<bpmnScriptTask, script task>>, the script that is executed has similar capabilities as a Java delegate. It has full access to the JVM, can run forever (due to infinite loops) or use up a lot of memory. However, Java delegates need to be written and put on the classpath in a jar and they have a different lifecyle from a process definitions. End-users generally will not write Java delegates, as this is a typical the job of a developer.

Scripts on the other hand are part of the process definition and its lifecycle is the same. Script tasks don't need the extra step of a jar deployment, but can be executed from the moment the process definition is deployed. Sometimes, scripts for script tasks are not written by developers. Yet, this poses a problem as stated above: a script has full access to the JVM and it is possible to block many system resources when executing the script. Allowing scripts from just about anyone is thus not a good idea.

To solve this problem, the _secure scripting_ feature can be enabled. Currently, this feature is implemented for _javascript_ scripting only. To enable it, add the _activiti-secure-javascript_ dependency to your project. When using maven:

[source,xml,linenums]
----
<dependency>
    <groupId>org.activiti</groupId>
    <artifactId>activiti-secure-javascript</artifactId>
    <version>${activiti.version}</version>
</dependency>
----

Adding this dependency will transitively bring in the Rhino dependency (see link:$https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino$$[https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino]). Rhino is a javascript engine for the JDK. It used to be included in JDK version 6 and 7 and was superseded by the Nashorn engine. However, the Rhino project continued development after it was included in the JDK. Many features (including the ones Activiti uses to implement the secure scripting) were added afterwards. At the time of writing, the Nashorn engine *does not* have the features that are needed to implement the secure scripting feature.

This does mean that there could be (typically small) differences between scripts (for example, _importPackage_ works on Rhino, but _load()_ has to be used on Nashorn). The changes would be similar to switching from JDK 7 to 8 scripts.

Configuring the secure scripting is done through a dedicated _Configurator_ object that is passed to the process engine configuration before the process engine is instantiated:

[source,java,linenums]
----
SecureJavascriptConfigurator configurator = new SecureJavascriptConfigurator()
  .setWhiteListedClasses(new HashSet<String>(Arrays.asList("java.util.ArrayList")))
  .setMaxStackDepth(10)
  .setMaxScriptExecutionTime(3000L)
  .setMaxMemoryUsed(3145728L)
  .setNrOfInstructionsBeforeStateCheckCallback(10);

processEngineConfig.addConfigurator(configurator);
----

Following settings are possible:

* *enableClassWhiteListing*: When true, all classes will be blacklisted and all classes that want to be used will need to be whitelisted individually. This gives tight control over what is exposed to scripts. By default _false_.
* *whiteListedClasses*: a Set of Strings corresponding with fully qualified classnames of the classes that are allowed to be used in the script. For example, to expose the _execution_ object in a script, the _org.activiti.engine.impl.persistence.entity.ExecutionEntity_ String needs to be added to this Set. By default _empty_.
* *maxStackDepth*: Limits the stack depth while calling functions within a script. This can be used to avoid stackoverflow exceptions that occur when recursively calling a method defined in the script. By default _-1_ (disabled).
* *maxScriptExecutionTime*: The maximum time a script is allowed to run. By default _-1_ (disabled).
* *maxMemoryUsed*: The maximum memory, in bytes, that the script is allowed to use. Note that the script engine itself takes a a certain amount of memory that is counted here too. By default _-1_ (disabled).
* *nrOfInstructionsBeforeStateCheckCallback*: The maximum script execution time and memory usage is implemented using a callback that is called every x instructions of the script. Note that these are not script instructions, but java byte code instructions (which means one script line could be hundreds of byte code instructions). By default 100.

_Note:_ the _maxMemoryUsed_ setting can only be used by a JVM that supports the com.sun.management.ThreadMXBean#getThreadAllocatedBytes() method. The Oracle JDK has this.

There is also a secure variant of the ScriptExecutionListener and ScriptTaskListener: _org.activiti.scripting.secure.listener.SecureJavascriptExecutionListener_ and _org.activiti.scripting.secure.listener.SecureJavascriptTaskListener_.

It's used as follows:

[source,xml,linenums]
----
<activiti:executionListener event="start" class="org.activiti.scripting.secure.listener.SecureJavascriptExecutionListener">
  <activiti:field name="script">
	  <activiti:string>
		  <![CDATA[
        execution.setVariable('test');
			]]>
	  </activiti:string>
	</activiti:field>
  <activiti:field name="language" stringValue="javascript" />
</activiti:executionListener>
----

For examples that demonstrate unsecure scripts and how they are made secure by the _secure scripting_ feature, please check the  link:$$https://github.com/Activiti/Activiti/tree/master/modules/activiti-secure-javascript/src/test/resources$$[unit tests on Github]
