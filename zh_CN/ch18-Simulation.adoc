
== 使用Activiti-Crystalball仿真（试验性） Simulation with Activiti-Crystalball (Experimental)

[[crb-introduction]]


=== 介绍 Introduction

[[crb-overview]]

==== 简介 Short overview

activiti-crystalball（CrystalBall）是一个用于Activiti业务流程管理平台的仿真引擎。CrystalBall仿真可以用于：
      
* 支持决策——对于生产工作流（例如，我们是否要在系统中增加更多资源，以满足截止日期？）。
* 优化与理解——测试变更并理解其影响。
* 培训——仿真可以在员工铺开使用前进行培训。
* ... 


[[crb-unique]]


==== CrystalBall是唯一的 CrystalBall is unique

不需要：

* 创建单独的仿真模型与引擎。
* 为仿真创建不同的报告。
* 为仿真引擎提供大量数据。

CrystalBall仿真器基于Activiti。这就是为什么可以很轻易地复制数据并启动仿真，也可以从历史中重放工作流行为。
    

[[crb-inside]]


=== 深入CrystalBall (CrystalBall inside)

CrystalBall是一个link:$$http://en.wikipedia.org/wiki/Discrete_event_simulation$$[离散事件仿真器]。最简单的实现是org.activiti.crystalball.simulator.SimpleSimulationRun。

[source,java,linenums]  
----
init();

SimulationEvent event = removeSimulationEvent();

while (!simulationEnd(event)) {
	executeEvent(event);
	event = removeSimulationEvent();
}

close();  
----

SimulationRun也可以执行不同来源生成的仿真事件（参见link:$$#crb-playback$$[回放]）。


[[crb-history-analysis]]


=== 历史分析 History analysis

仿真的一个使用场景是用于分析历史。生产环境不能用于重现并查找bug。这就是为什么几乎不可能将流程引擎调整到生产环境发生bug时一样的状态。问题不在硬件而是：

* 时间——流程实例可能需要好几个月。
* 并发——流程实例运行时可能与其它的实例相互影响，只有在它们都并行执行的时候才会发现问题。
* 用户——大量用户可以参与流程实例执行。将流程实例调整到错误发生时的状态会花费大量精力。


The simulation can address mentioned issues easily. Simulation time is virtual and does not depend on real time. Activiti process engine itself is virtual. There is no need to create virtual process engine which is used in the simulation experiment. In this case concurrency can be addressed naturally. Users' behavior can be logged and replayed from this log or predicted and generated on demand.
      
The best way to analyze history is to re-live it once more time. The re-living is hardly achievable in real life but it can be achieved by simulation.
      

[[crb-collectEvents]]


==== Events from the history.


The most important thing to re-live the history is to collect events which affected world status. Let's say that our process is driven by user events (e.g. claim, complete task...). In such a case we have can use two event sources:
          
* process history - currently supported only in original link:$$http://gro-mar.github.io/activiti-crystalball/$$[activiti-crystalball] project.
* logged ActivitiEvents. Basically we can add ActivitiEventListener to the engine from which we want to log events. Logged events are stored and after the time analyzed. The basic implementation is org.activiti.crystalball.simulator.delegate.event.impl.InMemoryRecordActivitiEventListener:

[source,java,linenums]
----
@Override
public void onEvent(ActivitiEvent event) {
  Collection<SimulationEvent> simulationEvents = transform(event);
  store(simulationEvents);
}
----

Events are stored. We can continue in re-living the history again.
        

[[crb-playback]]


==== PlayBack

The good thing on the playback is that it can be played over and over again till we do not completely understand what has happened. Crystalball simulation is based on real data, real user behavior and it is Crystalball's advantage.
        
The best way to understand how playback works is to explain step by step an example based on JUnit test org.activiti.crystalball.simulator.delegate.event.PlaybackRunTest. The process on which simulation is tested is the simplest one:

[source,xml,linenums]
----
<process id="theSimplestProcess" name="Without task Process">
  <documentation>This is a process for testing purposes</documentation>

  <startEvent id="theStart"/>
  <sequenceFlow id="flow1" sourceRef="theStart" targetRef="theEnd"/>
  <endEvent id="theEnd"/>

</process>
----

This process is deployed and used in real and simulation run.
          
* record events

[source,java,linenums]
----
// get process engine with record listener to log events
ProcessEngine processEngine = (new RecordableProcessEngineFactory(THE_SIMPLEST_PROCESS, listener)).getObject();

// start process instance with variables
Map<String,Object> variables = new HashMap<String, Object>();
variables.put(TEST_VARIABLE, TEST_VALUE);
processEngine.getRuntimeService().startProcessInstanceByKey(SIMPLEST_PROCESS, BUSINESS_KEY,variables);

// check process engine status - there should be one process instance in the history
checkStatus(processEngine);

// close and destroy process engine
EventRecorderTestUtils.closeProcessEngine(processEngine, listener);
ProcessEngines.destroy();
----

Code snippet above will record ActivitiEventType.ENTITY_CREATED after startProcessInstanceByKey method invocation.
              
* start simulation run

[source,java,linenums]
----
final SimpleSimulationRun.Builder builder = new SimpleSimulationRun.Builder();
// init simulation run
// get process engine factory - the only difference from RecordableProcessEngineFactory that log listener is not added
DefaultSimulationProcessEngineFactory simulationProcessEngineFactory = new DefaultSimulationProcessEngineFactory(THE_SIMPLEST_PROCESS);
// configure simulation run
builder.processEngine(simulationProcessEngineFactory)
       // set playback event calendar from recorded events
       .eventCalendar(new PlaybackEventCalendarFactory(new SimulationEventComparator(), listener.getSimulationEvents()))
       // set handlers for simulation events
       .customEventHandlerMap(EventRecorderTestUtils.getHandlers());
SimpleSimulationRun simRun = builder.build();

simRun.execute(new NoExecutionVariableScope());

// check the status - the same method which was used in record events method
checkStatus(simulationProcessEngineFactory.getObject());

// close and destroy process engine
simRun.getProcessEngine().close();
ProcessEngines.destroy();
----

More advanced playback examples are in org.activiti.crystalball.simulator.delegate.event.PlaybackProcessStartTest
        

[[crb-debug]]


==== Process engine debugger


Playback limits us to execute all simulation events (e.g. start process, complete task) in one bunch. Debugger allows us to split execution into smaller steps and observe process engine status between the steps.
        
SimpleSimulationRun implements SimulationDebugger interface. SimulationDebugger allows to execute simulation events step by step, to run simulation to the specified time.

[source,java,linenums]
----
  /**
  * Allows to run simulation in debug mode
  */
  public interface SimulationDebugger {
  /**
  * initialize simulation run
  * @param execution - variable scope to transfer variables from and to simulation run
  */
  void init(VariableScope execution);

  /**
  * step one simulation event forward
  */
  void step();

  /**
  * continue in the simulation run
  */
  void runContinue();

  /**
  * execute simulation run till simulationTime
  */
  void runTo(long simulationTime);

  /**
  * execute simulation run till simulation event of the specific type
  */
  void runTo(String simulationEventType);

  /**
  * close simulation run
  */
  void close();
}
----


To see process engine debugger in action run SimpleSimulationRunTest
        

[[crb-replay]]


==== Replay

Playback needs to create another process engine instance. Playback does not affect "real" environment, on the other side it needs simulation experiment configuration. Replay works on the "real" process engine. Replay executes simulation event on the running process engine. The consequence is that replay lives in real time. Real time means that simulation events are scheduled to be executed immediately.
        
Example bellow shows how to replay one process instance. The same technique can be applied in playback to for playing only one process instance. (ReplayRunTest) The first part of the test initialize process engine, starts one process instance and completes process instance's task.

[source,java,linenums]
----
  ProcessEngine processEngine = initProcessEngine();

  TaskService taskService = processEngine.getTaskService();
  RuntimeService runtimeService = processEngine.getRuntimeService();

  Map<String, Object> variables = new HashMap<String, Object>();
  variables.put(TEST_VARIABLE, TEST_VALUE);
  ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(USERTASK_PROCESS, BUSINESS_KEY,
  variables);

  Task task = taskService.createTaskQuery().taskDefinitionKey("userTask").singleResult();
  TimeUnit.MILLISECONDS.sleep(50);
  taskService.complete(task.getId());
----

Used process engine is basic InMemoryStandaloneProcessEngine with
          
* InMemoryRecordActivitiEventListener (already used in playback) to record Activiti events and transform them to simulation events.
* UserTaskExecutionListener - when new user task is created and new task is form replay process instance, schedule task complete event to the event calendar.

Next test part starts simulation debugger on the same process engine as original process. Replay event handlers replaces StartProcessEventHandler with StartReplayProcessEventHandler. StartReplayProcessEventHandler takes process instance Id to replay and in the init phase schedule process instance start. StartProcessEventHandler in the handle phase starts new process instance with one reserved variable. Variable name is "_replay.processInstanceId". The variable is used to store id of the process which is replayed. ReplaySimulationRun in comparison with SimpleSimulationRun does not:
          
* create and close process engine instance.
* change simulation time. (real time cannot be changed)
[source,java,linenums]

----
final SimulationDebugger simRun = new ReplaySimulationRun(processEngine,
  getReplayHandlers(processInstance.getId()));
----

And now replay process instance can start. At the beginning there are no process instances running. There is one process instance finished in the history. After the init there is one simulation event in the event calendar - to start process instance which replays already finished process instance.

[source,java,linenums]
----
simRun.init();

// original process is finished - there should not be any running process instance/task
assertEquals(0, runtimeService.createProcessInstanceQuery().processDefinitionKey(USERTASK_PROCESS).count());
assertEquals(0, taskService.createTaskQuery().taskDefinitionKey("userTask").count());

simRun.step();

// replay process was started
assertEquals(1, runtimeService.createProcessInstanceQuery().processDefinitionKey(USERTASK_PROCESS).count());
// there should be one task
assertEquals(1, taskService.createTaskQuery().taskDefinitionKey("userTask").count());
----

When the task was created UserTaskExecutionListener created new simulation event to complete user task.

[source,java,linenums]
----
simRun.step();

// userTask was completed - replay process was finished
assertEquals(0, runtimeService.createProcessInstanceQuery().processDefinitionKey(USERTASK_PROCESS).count());
assertEquals(0, taskService.createTaskQuery().taskDefinitionKey("userTask").count());
----

Simulation is finished and we can continue in another process instance start, or any other events. For now we can close simRun and process engine.

[source,java,linenums]
----
simRun.close();
processEngine.close();
ProcessEngines.destroy();
----


        

