[[activitiDesigner]]

== Eclipse Designer

Activiti提供了名为Activiti Eclipse Designer的Eclipse插件，可以用于图形化地建模、测试与部署BPMN 2.0流程。

[[eclipseDesignerInstallation]]


=== 安装 Installation

下面的安装指导在link:$$http://www.eclipse.org/downloads/$$[Eclipse Kepler与Indigo]进行了验证。请注意**不**支持Eclipse Helios。

选择**Help -> Install New Software**。在下图面板中，点击__Add__按钮，并填写下列字段：

* *Name:*Activiti BPMN 2.0 designer
* *Location:*http://activiti.org/designer/update/

image::images/designer.add.update.site.png[align="center"]

确保**"Contact all updates sites.."**单选框**已选中**，因为这样Eclipse就可以下载需要的所有插件。

[[eclipseDesignerEditorFeatures]]


=== Activiti Designer设计器功能 (Activiti Designer editor features)

* 创建Activiti项目与流程图（diagram）。

image::images/designer.create.activiti.project.png[align="center"]

* Activiti Designer在创建新的Activiti diagram时，创建一个.bpmn文件。当使用Activiti Diagram Editor（Activiti流程图编辑器）视图打开时，将提供图形化的模型画布与画板。这个文件也可以使用XML编辑器打开，将显示流程定义的BPMN 2.0 XML元素。因此Activiti Designer只用一个文件，既是流程图，也是BPMN 2.0 XML。请注意在Activiti 5.9版本中，还不支持使用.bpmn扩展名作为流程定义的部署包。因此Activiti Designer的"create deployment artifacts（创建部署包）"功能，将生成一个BAR文件，与一个包含.bpmn文件内容的.bpmn20.xml文件。也可以方便的自己重命名。也请注意，也可以使用Activiti Diagram Editor打开.bpmn20.xml文件。

image::images/designer.bpmn.file.png[align="center"]


* 可以将BPMN 2.0 XML文件导入Activiti Designer，流程图会自动创建。只需要将BPMN 2.0 XML文件复制到项目中，并使用Activiti Diagram Editor视图打开它。Activiti Designer使用文件中的BPMN DI信息来创建流程图。如果BPMN 2.0 XML文件中没有BPMN DI信息，则不会创建流程图。

image::images/designer.open.importedfile.png[align="center"]

* 要进行部署，可以使用Activiti Designer创建BAR文件，或JAR文件。在包浏览器中的Activiti项目上点击右键，在弹出菜单的下方选择__Create deployment artifacts（创建部署包）__选项。要了解关于Designer部署功能的更多信息，请查看<<eclipseDesignerDeployment,部署>>章节。

image::images/designer.create.deployment.png[align="center"]


* 生成单元测试（在宝浏览器中的BPMN 2.0 XML文件上点击右键，选择__generate unit test 生成单元测试__）。将创建一个单元测试与运行在嵌入式H2数据库上的Activiti配置。这样就可以运行单元测试以测试你的流程定义。

image::images/designer.unittest.generate.png[align="center"]


* Activiti项目生成为Maven项目。要配置依赖，需要运行__mvn eclipse:eclipse__，这样就会按预期配置Maven依赖。请注意对于流程设计来说，不要Maven依赖。只在运行单元测试时才需要依赖。

image::images/designer.project.maven.png[align="center"]


[[eclipseDesignerBPMNFeatures]]


=== Activiti Designer BPMN功能 (Activiti Designer BPMN features)



* 支持空启动事件，错误启动事件，定时器启动事件，空结束事件，错误结束事件，顺序流，并行网关，排他网关，包容网关，事件网关，嵌入式子流程，事件子流程，调用活动，泳池，泳道，脚本任务，用户任务，服务任务，邮件任务，手动任务，业务规则任务，接收任务，定时器边界事件，错误边界事件，信号边界事件，定时器捕获事件，信号捕获事件，信号抛出事件，空抛出事件，与四个Alfresco特有元素（用户，脚本，邮件任务与启动事件）。

image::images/designer.model.process.png[align="center"]

* 可以通过在元素上悬停并选择新的任务类型，快速改变任务的类型。

image::images/designer.model.quick.change.png[align="center"]

* 可以通过在元素上悬停并选择新的元素类型，快速添加新的元素。

image::images/designer.model.quick.new.png[align="center"]

* Java服务任务支持Java类，表达式或代理表达式配置。另外也可以配置字段扩展。

image::images/designer.servicetask.property.png[align="center"]

* 支持泳池与泳道。因为Activiti将不同的泳池认作不同的流程定义，因此最好只使用一个泳池。如果使用多个泳池，要小心不要在泳池间画顺序流，否则会在Activiti引擎中部署流程时发生错误。可以在一个泳池中添加任意多的泳道。

image::images/designer.model.poolandlanes.png[align="center"]

* 可以通过填写name参数，为顺序流添加标签。可以决定放置标签的位置，位置将保存为BPMN 2.0 XML DI信息的一部分。

image::images/designer.model.labels.png[align="center"]

* 支持事件子流程。

image::images/designer.model.eventsubprocess.png[align="center"]

* 支持展开嵌入式子流程。也可以在一个嵌入式子流程中加入另一个嵌入式子流程。

image::images/designer.embeddedprocess.canvas.png[align="center"]

* 支持在任务与嵌入式子流程上的定时器边界事件。然而，在Activiti Designer中，在用户任务或嵌入式子流程上使用定时器边界事件最合理。

image::images/designer.timerboundary.canvas.png[align="center"]


* 支持额外的Activiti扩展，例如邮件任务，用户任务的候选人配置，或脚本任务配置。

image::images/designer.mailtask.property.png[align="center"]

* 支持Activiti执行与任务监听器。也可以为执行监听器添加字段扩展。

image::images/designer.listener.configuration.png[align="center"]

* 支持在顺序流上添加条件。

image::images/designer.sequence.condition.png[align="center"]


[[eclipseDesignerDeployment]]


=== Activiti Designer部署功能 (Activiti Designer deployment features)

在Activiti引擎上部署流程定义与任务表单并不困难。需要有一个包含有流程定义BPMN 2.0 XML文件的BAR文件，与可选的任务表单和流程图片，可以在Activiti Explorer中查看。在Activiti Designer中，创建BAR文件十分简单。在完成流程实现后，只要在包浏览器中的Activiti项目上点击右键，在弹出菜单下方选择**Create deployment artifacts（创建部署包）**选项。

image::images/designer.create.deployment.png[align="center"]

然后就会创建一个部署目录，包含BAR文件，与可能的JAR文件。其中JAR文件包含Activiti项目中的Java类。

image::images/designer.deployment.dir.png[align="center"]

这样就可以在Activiti Explorer的部署页签中，将这个文件上传至Activiti引擎。

如果项目包含Java类，部署需要多做一些工作。在这种情况下，Activiti Designer的**Create deployment artifacts（创建部署包）**操作也会创建包含编译后类的JAR文件。这个JAR文件必须部署在Activiti Tomcat安装目录的activiti-XXX/WEB-INF/lib目录下。浙江使Activiti引擎的classpath可以使用这些类。


[[eclipseDesignerExtending]]


=== 扩展Activiti Designer (Extending Activiti Designer)

可以扩展Activiti Designer提供的默认功能。这段文档介绍了可以使用哪些扩展，如何使用，并提供了一些例子。在建模业务流程时，默认功能不能满足需要，需要额外的功能，或有领域专门需求的时候，扩展Activiti Designer就很有用。扩展Activiti Designer分为两个不同领域，扩展画板与扩展输出格式。两种方式都需要专门的方法，与不同的技术知识。


[NOTE]
====
扩展Activiti Designer需要专业知识，更确切地说，Java编程的知识。取决于你想要创建的扩展类型，你可能需要熟悉Maven，Eclipse，OSGi，Eclipse扩展与SWT。
====


[[eclipseDesignerCustomizingPalette]]


==== 自定义画板 Customizing the palette

可以自定义为用户建模流程提供的画板。画板是形状的集合，显示在画布的右手侧，可以将形状拖放至画布中的流程图上。在默认画板中可以看到，默认形状进行了分组（被称为“抽屉 drawer”），如事件，网关，等等。Activiti Designer内建了两个选项，用于自定义画板中的抽屉与形状：

* 将你自己的形状/节点添加到已有或新建的抽屉
* 禁用Activiti Designer提供的部分或全部BPMN 2.0默认形状，除了连线与选择工具

要自定义画板，需要创建一个JAR文件，并加入Activiti Designer安装目录（后面介绍<<eclipseDesignerApplyingExtension,如何做>>）。这个JAR文件叫做__扩展（extension）__。通过编写扩展中包含的类，就能让Activiti Designer知道你需要自定义什么。要做到这个，你的类需要实现特定的接口。有一个集成类库，包含这些接口，与需要加入你的classpath的用于扩展的基类。

可以在下列地方找到代码示例：Activiti源码的++projects/designer++目录下的++examples/money-tasks++目录。


[NOTE]
====
可以使用你喜欢的任何工具设置项目，并使用你选择的构建工具构建JAR。在下面的介绍中，假设使用Eclipse Kepler或Indigo，并使用Maven（3.x）作为构建工具。但任何设置都可以创建相同的结果。
====


===== 设置扩展（Eclipse/Maven） Extension setup (Eclipse/Maven)

下载并解压缩link:$$http://www.eclipse.org/downloads$$[Eclipse]（应该可以使用最新版本），与link:$$http://maven.apache.org/download.html$$[Apache Maven]近期的版本（3.x）。如果使用2.x版本的Maven，可能会在构建项目时遇到错误。因此请确保版本是最新的。我们假设你已经熟悉Eclipse中基本功能的使用与Java编辑器。可以使用Eclipse的Maven功能，或直接从命令行运行Maven命令。

在Eclipse中创建一个新项目。可以是通用类型项目。在项目的根路径创建一个++pom.xml++文件，以包含Maven项目配置。同时创建++src/main/java++与++src/main/resources++目录，这是Maven约定的Java源文件与资源文件目录。打开++pom.xml++文件并添加下列行：


[source,xml,linenums]
----
<project
  xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

  <modelVersion>4.0.0</modelVersion>

  <groupId>org.acme</groupId>
  <artifactId>money-tasks</artifactId>
  <version>1.0.0</version>
  <packaging>jar</packaging>
  <name>Acme Corporation Money Tasks</name>
...
</project>
----

可以看到，这只是一个基础的pom.xml文件，为项目定义了一个++groupId++，++artifactId++与++version++。我们会创建一个定制项，包含一个对money业务的自定义节点。

++pom.xml++文件中包含依赖，为项目依赖添加集成库：

[source,xml,linenums]
----
<dependencies>
  <dependency>
    <groupId>org.activiti.designer</groupId>
    <artifactId>org.activiti.designer.integration</artifactId>
    <version>5.12.0</version> <!-- Use the current Activiti Designer version -->
    <scope>compile</scope>
  </dependency>
</dependencies>
...
<repositories>
  <repository>
      <id>Activiti</id>
      <url>https://maven.alfresco.com/nexus/content/groups/public/</url>
   </repository>
</repositories>
----

最终，在++pom.xml++文件中，添加++maven-compiler-plugin++配置，设置Java源码级别为1.5以上（参见下面的代码片段）。要使用注解需要这个配置。也可以为Maven包含用于生成JAR的++MANIFEST.MF++文件。这不是必须有的，但可以在这个manifest中使用特定参数，为你的扩展提供名字（这个名字可以在设计器的特定位置显示，主要用于在设计器中有多个扩展时使用）。如果想要这么做，在++pom.xml++中添加下列代码片段：

[source,xml,linenums]
----
<build>
  <plugins>
        <plugin>
      <artifactId>maven-compiler-plugin</artifactId>
      <configuration>
        <source>1.5</source>
        <target>1.5</target>
        <showDeprecation>true</showDeprecation>
        <showWarnings>true</showWarnings>
        <optimize>true</optimize>
      </configuration>
    </plugin>
    <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-jar-plugin</artifactId>
      <version>2.3.1</version>
      <configuration>
        <archive>
          <index>true</index>
          <manifest>
            <addClasspath>false</addClasspath>
            <addDefaultImplementationEntries>true</addDefaultImplementationEntries>
          </manifest>
          <manifestEntries>
            <ActivitiDesigner-Extension-Name>Acme Money</ActivitiDesigner-Extension-Name>
          </manifestEntries>
        </archive>
      </configuration>
    </plugin>
  </plugins>
</build>
----


扩展的名字使用++ActivitiDesigner-Extension-Name++参数描述。现在只剩下告诉Eclipse按照++pom.xml++的指导设置项目。因此打开命令行，并转到Eclipse工作空间中你项目的根目录。然后执行下列Maven命令：

----
mvn eclipse:eclipse
----

等待构建完成。刷新项目（使用项目上下文菜单（右键点击），并选择++Refresh 刷新++）。现在Eclipse项目中应该有++src/main/java+ and +src/main/resources++目录作为源码目录。


[NOTE]
====
当然也可以使用link:$$http://www.eclipse.org/m2e$$[m2eclipse]插件，并简单地在项目的上下文菜单（右键点击）中启用Maven依赖管理。然后在项目的上下文菜单中选择++Maven++ > ++Update project configuration（更新项目配置）++。这也将配置源代码目录。
====

这就完成了配置。现在可以开始为Activiti Designer创建自定义项了！

[[eclipseDesignerApplyingExtension]]


===== 在Activiti Designer中应用你的扩展 Applying your extension to Activiti Designer

你也许想知道如何将你的扩展加入Activiti Designer，以便应用你的自定义项。需要这些步骤：
* 创建扩展JAR（例如，要使用Maven构建，在项目中运行mvn install）后，需要将扩展传递至Activiti Designer安装的计算机；
* 将扩展存储在硬盘上，方便记忆的位置。__请注意：__必须保存在Activiti Designer的Eclipse工作空间之外——将扩展保存在工作空间内，会导致弹出错误消息弹框，扩展将不可用；
* 启动Activiti Designer，从菜单中，选择++Window++ > ++Preferences++
* 在Preferences界面，键入++user++作为关键字。将可以看到在Eclipse中++Java++段落内，++User Libraries++的选项。

image::images/designer.preferences.userlibraries.png[align="center"]


* 选择++User Libraries++选项，将在右侧显示树形界面，可以添加库。应该可以看到一个默认组，可以添加Activiti Designer的扩展（根据Eclipse安装不同，也可能看到几个其他的）。

image::images/designer.preferences.userlibraries.activiti.empty.png[align="center"]


* 选择++Activiti Designer Extensions++组，并点击++Add JARs...++按钮。跳转至存储扩展的目录，并选择希望添加的扩展文件。完成后，配置界面会将扩展作为++Activiti Designer Extensions++组的成员进行显示，像下面这样。

image::images/designer.preferences.userlibraries.activiti.moneytasks.png[align="center"]


* 点击++OK++按钮保存并关闭配置对话框。++Activiti Designer Extensions++会自动添加至你创建的新Activiti项目。可以在导航条或包管理器的项目树下的用户库条目中看到。如果工作空间中已经有了Activiti项目，也可以看到组中显示了新扩展，像下面这样。

image::images/designer.userlibraries.project.png[align="center"]

打开的流程图将在其画板上显示新扩展的图形（或者禁用部分图形，取决于扩展中的配置）。如果已经打开了流程图，关闭并重新打开就能在画板上看到变化。


===== 为画板添加图形 Adding shapes to the palette

项目配置完后，可以很轻松的为画板添加图形。每个想添加的图形都表现为JAR中的一个类。请注意这些类并不是Activiti引擎运行时会使用的类。在扩展中可以为每个图形描述Activiti Designer可用的参数。从这些图形中，也可以定义运行时特性，将在流程实例到达流程的该节点时，由引擎使用。运行时特性可以使用任何Activiti对普通++ServiceTask++支持的选项。查看<<eclipseDesignerConfiguringRuntime,这个章节>>了解更多信息。

图形的类是简单的Java类，加上一些注解。这个类需要实现++CustomServiceTask++接口，但不应该自行实现这个接口，而应该扩展++AbstractCustomServiceTask++基类（目前必须直接扩展这个类，而不能在中间使用abstract类）。在这个类的Javadoc中，可以看到其魔人提供的，与需要覆盖的方法介绍。覆盖使你可以实现例如为画板及画布中的图形提供图标（两个可以不一样），或者指定你希望节点实现的基图形（活动，时间，网关）。


[source,java,linenums]
----
/**
 * @author John Doe
 * @version 1
 * @since 1.0.0
 */
public class AcmeMoneyTask extends AbstractCustomServiceTask {
...
}
----

需要实现++getName()++方法，决定节点在画板上的名字。也可以将节点放在自己的抽屉中，并提供图标。覆盖++AbstractCustomServiceTask++的对应方法。如果希望提供图标，请确保放在JAR的++src/main/resources++包中，需要是16X16像素的JPEG或PNG格式图片。你要提供的路径与这个目录有关。

可以通过在类中添加成员，并使用++@Property++注解，来为形状添加参数。像这样：

[source,java,linenums]
----
@Property(type = PropertyType.TEXT, displayName = "Account Number")
@Help(displayHelpShort = "Provide an account number", displayHelpLong = HELP_ACCOUNT_NUMBER_LONG)
private String accountNumber;
----

可以使用多种++PropertyType++值，在<<eclipseDesignerPropertyTypes,这个章节>>中详细描述。可以通过将必填属性设置为true，将一个字段设为必填。如果用户没有填写这个字段，将会提示消息，背景也会变红。

如果想要确保类中多个参数在参数界面上的显示顺序，需要指定++@Property++注解的order属性。

可以看到有个++@Help++注解，它用于为用户提供一些填写字段的指导。也可以在类本身上使用++@Help++注解——这个信息将在显示给用户的参数表格最上面显示。

下面是++MoneyTask++详细介绍的列表。添加了一个备注字段，也可以看到节点包含了一个图标。


[source,java,linenums]
----
/**
 * @author John Doe
 * @version 1
 * @since 1.0.0
 */
@Runtime(javaDelegateClass = "org.acme.runtime.AcmeMoneyJavaDelegation")
@Help(displayHelpShort = "创建一个新的账户 Creates a new account", displayHelpLong = "使用给定的账户编码，创建一个新的账户 Creates a new account using the account number specified")
public class AcmeMoneyTask extends AbstractCustomServiceTask {

  private static final String HELP_ACCOUNT_NUMBER_LONG = "提供一个可用作账户编码的编码。 Provide a number that is suitable as an account number.";

  @Property(type = PropertyType.TEXT, displayName = "Account Number", required = true)
  @Help(displayHelpShort = "提供一个账户编码 Provide an account number", displayHelpLong = HELP_ACCOUNT_NUMBER_LONG)
  private String accountNumber;

  @Property(type = PropertyType.MULTILINE_TEXT, displayName = "Comments")
  @Help(displayHelpShort = "提供备注 Provide comments", displayHelpLong = "可以为节点添加备注，以提供详细说明。 You can add comments to the node to provide a brief description.")
  private String comments;

  /*
   * (non-Javadoc)
   *
   * @see org.activiti.designer.integration.servicetask.AbstractCustomServiceTask #contributeToPaletteDrawer()
   */
  @Override
  public String contributeToPaletteDrawer() {
    return "Acme Corporation";
  }

  @Override
  public String getName() {
    return "Money node";
  }

  /*
   * (non-Javadoc)
   *
   * @see org.activiti.designer.integration.servicetask.AbstractCustomServiceTask #getSmallIconPath()
   */
  @Override
  public String getSmallIconPath() {
    return "icons/coins.png";
  }
}
----

如果使用这个图形扩展Activiti Designer，画板与相应的图形将像是这样：

image::images/designer.palette.add.money.png[align="center"]

money任务的参数界面在下面显示。请注意++accountNumber++字段的必填信息。

image::images/designer.palette.add.money.properties.required.png[align="center"]

在创建流程图时，填写参数字段时，用户可以使用静态文本，或者使用流程变量的表达式（如"This little piggy went to ${piggyLocation}"）。一般来说，用户可以在text字段自由填写任何文本。如果你希望用户使用表达式，并（使用++@Runtime++）为++CustomServiceTask++添加运行时行为，请确保在代理类中使用++Expression++字段，以便表达式可以在运行时正确解析。可以在<<eclipseDesignerConfiguringRuntime,这个章节>>找到更多关于运行时行为的信息。

字段的帮助信息由每个参数右侧的按钮提供。点击该按钮将弹出显示下列内容。

image::images/designer.palette.add.money.help.png[align="center"]


[[eclipseDesignerConfiguringRuntime]]

====== 配置自定义服务任务的运行时执行 Configuring runtime execution of Custom Service Tasks

当设置好字段，并将扩展应用至Designer后，用户可以在建模流程时，配置服务任务的这些参数。在大多数情况下，会希望在Activiti执行流程时，使用这些用户配置参数。要做到这一点，必须告诉Activiti，当流程到达你++CustomServiceTask++时，需要实例化哪个类。

指定++CustomServiceTask++运行时特性，有一个特别的注解，++@Runtime++。这里有些如何使用的例子：


[source,java,linenums]
----
@Runtime(javaDelegateClass = "org.acme.runtime.AcmeMoneyJavaDelegation")
----

使用时，++CustomServiceTask++将会表现为流程建模BPMN中的一个普通的++ServiceTask++。Activiti提供了<<bpmnJavaServiceTask,多种方法>>定义++ServiceTask++的运行时特性。因此，++@Runtime++可以使用Activiti提供的三个属性中的一个：

* ++javaDelegateClass++在BPMN输出中映射为++activiti:class++。指定一个实现了++JavaDelegate++的类的全限定类名。
* ++expression++在BPMN输出中映射为+activiti:expression++。制定一个需要执行的方法的表达式，例如一个Spring Bean中的方法。当使用这个选项时，__不应__在字段上指定任何++@Property++注解。下面有更详细的说明。
* ++javaDelegateExpression++在BPMN输出中映射为++activiti:delegateExpression++。指定一个实现了++JavaDelegate++的类的表达式。

如果在类中为Activiti提供了可以注入的成员，就可以将用户的参数至注入到运行时类中。名字需要与++CustomServiceTask++的成员名一致。查看用户手册的<<serviceTaskFieldInjection,这个部分>>了解更多信息。请注意从Designer的5.11.0版本开始，可以为动态字段值使用++Expression++接口。这意味着Activiti Designer中参数的值必须要是表达式，并且这个表达式将在之后注入++JavaDelegate++实现类的++Expression++参数中。


[NOTE]
====

You can use +@Property+ annotations on members of your +CustomServiceTask+, but this will not work if you use ++@Runtime++'s +expression+ attribute. The reason for this is that the expression you specify will be attempted to be resolved to a _method_ by Activiti, not to a class. Therefore, no injection into a class will be performed. Any members marked with +@Property+ will be ignored by Designer if you use +expression+ in your +@Runtime+ annotation. Designer will not render them as editable fields in the node's property pane and will produce no output for the properties in the process' BPMN.
====

[NOTE]
====
Note that the runtime class shouldn't be in your extension JAR, as it's dependent on the Activiti libraries. Activiti needs to be able to find it at runtime, so it needs to be on the Activiti engine's classpath.
====

The examples project in Designer's source tree contains examples of the different options for configuring +@Runtime+. Take a look in the money-tasks project for some starting points. The examples refer to delegate class examples that are in the money-delegates project.


[[eclipseDesignerPropertyTypes]]


===== Property types

This section describes the property types you can use for a +CustomServiceTask+ by setting its type to a +PropertyType+ value.

====== PropertyType.TEXT

Creates a single line text field as shown below. Can be a required field and shows validation messages as a tooltip. Validation failures are displayed by changing the background of the field to a light red color.

image::images/designer.property.text.invalid.png[align="center"]

====== PropertyType.MULTILINE_TEXT

Creates a multiline text field as shown below (height is fixed at 80 pixels). Can be a required field and shows validation messages as a tooltip. Validation failures are displayed by changing the background of the field to a light red color.

image::images/designer.property.multiline.text.invalid.png[align="center"]


====== PropertyType.PERIOD

Creates a structured editor for specifying a period of time by editing amounts of each unit with a spinner control. The result is shown below. Can be a required field (which is interpreted such that not all values may be 0, so at least 1 part of the period must have a non-zero value) and shows validation messages as a tooltip. Validation failures are displayed by changing the background of the entire field to a light red color. The value of the field is stored as a string of the form 1y 2mo 3w 4d 5h 6m 7s, which represents 1 year, 2 months, 3 weeks, 4 days, 6 minutes and 7 seconds. The entire string is always stored, even if parts are 0.

image::images/designer.property.period.png[align="center"]


====== PropertyType.BOOLEAN_CHOICE

Creates a single checkbox control for boolean or toggle choices. Note that you can specify the +required+ attribute on the +Property+ annotation, but it will not be evaluated because that would leave the user without a choice whether to check the box or not. The value stored in the diagram is java.lang.Boolean.toString(boolean), which results in "true" or "false".

image::images/designer.property.boolean.choice.png[align="center"]

====== PropertyType.RADIO_CHOICE

Creates a group of radio buttons as shown below. Selection of any of the radio buttons is mutually exclusive with selection of any of the others (i.e., only one selection allowed). Can be a required field and shows validation messages as a tooltip. Validation failures are displayed by changing the background of the group to a light red color.

This property type expects the class member you have annotated to also have an accompanying +@PropertyItems+ annotation (for an example, see below). Using this additional annotation, you can specify the list of items that should be offered in an array of Strings. Specify the items by adding two array entries for each item: first, the label to be shown; second, the value to be stored.

[source,java,linenums]
----
@Property(type = PropertyType.RADIO_CHOICE, displayName = "Withdrawl limit", required = true)
@Help(displayHelpShort = "The maximum daily withdrawl amount ", displayHelpLong = "Choose the maximum daily amount that can be withdrawn from the account.")
@PropertyItems({ LIMIT_LOW_LABEL, LIMIT_LOW_VALUE, LIMIT_MEDIUM_LABEL, LIMIT_MEDIUM_VALUE, LIMIT_HIGH_LABEL, LIMIT_HIGH_VALUE })
private String withdrawlLimit;
----

image::images/designer.property.radio.choice.png[align="center"]

image::images/designer.property.radio.choice.invalid.png[align="center"]


====== PropertyType.COMBOBOX_CHOICE

Creates a combobox with fixed options as shown below. Can be a required field and shows validation messages as a tooltip. Validation failures are displayed by changing the background of the combobox to a light red color.

This property type expects the class member you have annotated to also have an accompanying +@PropertyItems+ annotation (for an example, see below). Using this additional annotation, you can specify the list of items that should be offered in an array of Strings. Specify the items by adding two array entries for each item: first, the label to be shown; second, the value to be stored.

[source,java,linenums]
----
@Property(type = PropertyType.COMBOBOX_CHOICE, displayName = "Account type", required = true)
@Help(displayHelpShort = "The type of account", displayHelpLong = "Choose a type of account from the list of options")
@PropertyItems({ ACCOUNT_TYPE_SAVINGS_LABEL, ACCOUNT_TYPE_SAVINGS_VALUE, ACCOUNT_TYPE_JUNIOR_LABEL, ACCOUNT_TYPE_JUNIOR_VALUE, ACCOUNT_TYPE_JOINT_LABEL,
  ACCOUNT_TYPE_JOINT_VALUE, ACCOUNT_TYPE_TRANSACTIONAL_LABEL, ACCOUNT_TYPE_TRANSACTIONAL_VALUE, ACCOUNT_TYPE_STUDENT_LABEL, ACCOUNT_TYPE_STUDENT_VALUE,
  ACCOUNT_TYPE_SENIOR_LABEL, ACCOUNT_TYPE_SENIOR_VALUE })
private String accountType;
----

image::images/designer.property.combobox.choice.png[align="center"]

image::images/designer.property.combobox.choice.invalid.png[align="center"]


====== PropertyType.DATE_PICKER

Creates a date selection control as shown below. Can be a required field and shows validation messages as a tooltip (note, that the control used will auto-set the selection to the date on the system, so the value is seldom empty). Validation failures are displayed by changing the background of the control to a light red color.

This property type expects the class member you have annotated to also have an accompanying +@DatePickerProperty+ annotation (for an example, see below). Using this additional annotation, you can specify the date time pattern to be used to store dates in the diagram and the type of datepicker you would like to be shown. Both attributes are optional and have default values that will be used if you don't specify them (these are static variables in the +DatePickerProperty+ annotation). The +dateTimePattern+ attribute should be used to supply a pattern to the +SimpleDateFormat+ class. When using the +swtStyle+ attribute, you should specify an integer value that is supported by ++SWT++'s +DateTime+ control, because this is the control that is used to render this type of property.

[source,java,linenums]
----
@Property(type = PropertyType.DATE_PICKER, displayName = "Expiry date", required = true)
@Help(displayHelpShort = "The date the account expires ", displayHelpLong = "Choose the date when the account will expire if no extended before the date.")
@DatePickerProperty(dateTimePattern = "MM-dd-yyyy", swtStyle = 32)
private String expiryDate;
----

image::images/designer.property.date.picker.png[align="center"]



====== PropertyType.DATA_GRID

Creates a data grid control as shown below. A data grid can be used to allow the user to enter an arbitrary amount of rows of data and enter values for a fixed set of columns in each of those rows (each individual combination of row and column is referred to as a cell). Rows can be added and removed as the user sees fit.

This property type expects the class member you have annotated to also have an accompanying +@DataGridProperty+ annotation (for an example, see below). Using this additional annotation, you can specify some specific attributes of the data grid. You are required to reference a different class to determine which columns go into the grid with the +itemClass+ attribute. Activiti Designer expects the member type to be a +List+. By convention, you can use the class of the +itemClass+ attribute as its generic type. If, for example, you have a grocery list that you edit in the grid, you would define the columns of the grid in the +GroceryListItem+ class. From your +CustomServiceTask+, you would refer to it like this:

[source,java,linenums]
----
@Property(type = PropertyType.DATA_GRID, displayName = "Grocery List")
@DataGridProperty(itemClass = GroceryListItem.class)
private List<GroceryListItem> groceryList;
----


The "itemClass" class uses the same annotations you would otherwise use to specify fields of a +CustomServiceTask+, with the exception of using a data grid. Specifically, +TEXT+, +$$MULTILINE_TEXT$$+ and +PERIOD+ are currently supported. You'll notice the grid will create single line text controls for each field, regardless of the +PropertyType+. This is done on purpose to keep the grid graphically appealing and readable. If you consider the regular display mode for a +PERIOD+ +PropertyType+ for instance, you can imagine it would never properly fit in a grid cell without cluttering the screen. For +$$MULTILINE_TEXT$$+ and +PERIOD+, a double-click mechanism is added to each field which pops up a larger editor for the +PropertyType+. The value is stored to the field after the user clicks OK and is therefore readable within the grid.

Required attributes are handled in a similar manner to regular fields of type +TEXT+ and the entire grid is validated as soon as any field loses focus. The background color of the text control in a specific cell of the data grid is changed to light red if there are validation failures.

By default, the component allows the user to add rows, but not to determine the order of those rows. If you wish to allow this, you should set the +orderable+ attribute to true, which enables buttons at the end of each row to move it up or down in the grid.

[NOTE]
====
At the moment, this property type is not correctly injected into your runtime class.
====

image::images/designer.property.datagrid.png[align="center"]



===== Disabling default shapes in the palette

This customization requires you to include a class in your extension that implements the +DefaultPaletteCustomizer+ interface. You should not implement this interface directly, but subclass the +AbstractDefaultPaletteCustomizer+ base class. Currently, this class provides no functionality, but future versions of the +DefaultPaletteCustomizer+ interface will offer more capabilities for which this base class will provide some sensible defaults so it's best to subclass so your extension will be compatible with future releases.

Extending the +AbstractDefaultPaletteCustomizer+ class requires you to implement one method, +disablePaletteEntries()+, from which you must return a list of +PaletteEntry+ values. For each of the default shapes, you can disable it by adding its corresponding +PaletteEntry+ value to your list. Note that if you remove shapes from the default set and there are no remaining shapes in a particular drawer, that drawer will be removed from the palette in its entirety. If you wish to disable all of the default shapes, you only need to add +PaletteEntry.ALL+ to your result. As an example, the code below disables the Manual task and Script task shapes in the palette.

[source,java,linenums]
----
public class MyPaletteCustomizer extends AbstractDefaultPaletteCustomizer {

  /*
   * (non-Javadoc)
   *
   * @see org.activiti.designer.integration.palette.DefaultPaletteCustomizer#disablePaletteEntries()
   */
  @Override
  public List<PaletteEntry> disablePaletteEntries() {
    List<PaletteEntry> result = new ArrayList<PaletteEntry>();
    result.add(PaletteEntry.MANUAL_TASK);
    result.add(PaletteEntry.SCRIPT_TASK);
    return result;
  }

}
----


The result of applying this extension is shown in the picture below. As you can see, the manual task and script task shapes are no longer available in the +Tasks+ drawer.

image::images/designer.palette.disable.manual.and.script.png[align="center"]


To disable all of the default shapes, you could use something similar to the code below.

[source,java,linenums]
----
public class MyPaletteCustomizer extends AbstractDefaultPaletteCustomizer {

  /*
   * (non-Javadoc)
   *
   * @see org.activiti.designer.integration.palette.DefaultPaletteCustomizer#disablePaletteEntries()
   */
  @Override
  public List<PaletteEntry> disablePaletteEntries() {
    List<PaletteEntry> result = new ArrayList<PaletteEntry>();
    result.add(PaletteEntry.ALL);
    return result;
  }

}
----


The result will look like this (notice that the drawers the default shapes were in are no longer in the palette):

image::images/designer.palette.disable.all.png[align="center"]


==== Validating diagrams and exporting to custom output formats

Besides customizing the palette, you can also create extensions to Activiti Designer that can perform validations and save information from the diagram to custom resources in the Eclipse workspace. There are built-in extension points for doing this and this section explains how to use them.

[NOTE]
====
The ExportMarshaller functions were reintroduced recently. We are still working on the validation functionality. The documentation below details the old situation and will be updated when the new functionality is available.
====


Activiti Designer allows you to write extensions that validate diagrams. There are already validations of BPMN constructs in the tool by default, but you can add your own if you want to validate additional items such as modeling conventions or the values in properties of ++CustomServiceTask++s. These extensions are known as +Process Validators+.

You can also Activiti Designer to publish to additional formats when saving diagrams. These extensions are called +Export Marshallers+ and are invoked automatically by Activiti Designer on each save action by the user. This behavior can be enabled or disabled by setting a preference in Eclipse's preferences dialog for each format for which there is an extension detected. Designer will make sure your +ExportMarshaller+ is invoked when saving the diagram, depending on the user's preference.

Often, you will want to combine a +ProcessValidator+ and an +ExportMarshaller+. Let's say you have a number of ++CustomServiceTask++s in use that have properties you would like to use in the process that gets generated. However, before the process is generated, you want to validate some of those values first. Combining a +ProcessValidator+ and +ExportMarshaller+ is the best way to accomplish this and Activiti Designer enables you to plug your extensions into the tool seamlessly.

To create a +ProcessValidator+ or an +ExportMarshaller+, you need to create a different kind of extension than for extending the palette. The reason for this is simple: from your code you will need access to more APIs than those that are offered by the integration library. In particular, you will need classes that are available in Eclipse itself. So to get started, you should create an Eclipse plugin (which you can do by using Eclipse's PDE support) and package it in a custom Eclipse product or feature. It's beyond the scope of this user guide to explain all the details involved in developing Eclipse plugins, so the instructions below are limited to the functionality for extending Activiti Designer.

Your bundle should be dependent on the following libraries:

* org.eclipse.core.runtime
* org.eclipse.core.resources
* org.activiti.designer.eclipse
* org.activiti.designer.libs
* org.activiti.designer.util

Optionally, the org.apache.commons.lang bundle is available through Designer if you'd like to use that in your extension.


Both ++ProcessValidator++s and ++ExportMarshaller++s are created by extending a base class. These base classes inherit some useful methods from their superclass, the +AbstractDiagramWorker+ class. Using these methods you can create information, warning and error markers that show up in Eclipse's problems view for the user to figure out what's wrong or important. You can get to information about the diagram in the form of +Resources+ and +InputStreams+. This information is provided from the +DiagramWorkerContext+, which is available from the +AbstractDiagramWorker+ class.

It's probably a good idea to invoke +clearMarkers()+ as one of the first things you do in either a +ProcessValidator+ or an ++ExportMarshaller++; this will clear any previous markers for your worker (markers are automatically linked to the worker and clearing markers for one worker leaves other markers untouched). For example:


[source,java,linenums]
----
// Clear markers for this diagram first
clearMarkersForDiagram();
----

You should also use the progress monitor provided (in the ++DiagramWorkerContext++) to report your progress back to the user because validations and/or marshalling actions can take up some time during which the user is forced to wait. Reporting progress requires some knowledge of how you should use Eclipse's features. Take a look at link:$$http://www.eclipse.org/articles/Article-Progress-Monitors/article.html$$[this article] for a thorough explanation of the concepts and usage.

===== Creating a ProcessValidator extension

[NOTE]
====
Under review!
====


Create an extension to the +org.activiti.designer.eclipse.extension.validation.ProcessValidator+ extension point in your +plugin.xml+ file. For this extension point, you are required to subclass the +AbstractProcessValidator+ class.

[source,xml,linenums]
----
<?eclipse version="3.6"?>
<plugin>
  <extension
    point="org.activiti.designer.eclipse.extension.validation.ProcessValidator">
    <ProcessValidator
      class="org.acme.validation.AcmeProcessValidator">
    </ProcessValidator>
  </extension>
</plugin>
----


[source,java,linenums]
----
public class AcmeProcessValidator extends AbstractProcessValidator {
}
----


You have to implement a number of methods. Most importantly, implement +getValidatorId()+ so you return a globally unique ID for your validator. This will enable you to invoke it from and +ExportMarshaller+, or event let someone _else_ invoke your validator from their +ExportMarshaller+. Implement +getValidatorName()+ and return a logical name for your validator. This name is shown to the user in dialogs. In +getFormatName()+, you can return the type of diagram the validator typically validates.

The validation work itself is done in the +validateDiagram()+ method. From this point on, it's up to your specific functionality what you code here. Typically, however, you will want to start by getting hold of the nodes in the diagram's process, so you can iterate through them, collect, compare and validate data. This snippet shows you how to do this:

[source,java,linenums]
----
final EList<EObject> contents = getResourceForDiagram(diagram).getContents();
for (final EObject object : contents) {
  if (object instanceof StartEvent ) {
  // Perform some validations for StartEvents
  }
  // Other node types and validations
}
----


Don't forget to invoke +addProblemToDiagram()+ and/or +addWarningToDiagram()+, etc as you go through your validations. Make sure you return a correct boolean result at the end to indicate whether you consider the validation as succeeded or failed. This can be used by and invoking +ExportMarshaller+ to determine the next course of action.


===== Creating an ExportMarshaller extension

Create an extension to the +org.activiti.designer.eclipse.extension.ExportMarshaller+ extension point in your +plugin.xml+ file. For this extension point, you are required to subclass the +AbstractExportMarshaller+ class. This abstract base class provides you with a number of useful methods when marshalling to your own format, but most importantly it allows you to save resources to the workspace and to invoke validators.

An example implementation is available in Designer's examples folder. This example shows how to use the methods in the base class to get the basics done, such as accessing the diagram's +InputStream+, using its +BpmnModel+ and saving resources to the workspace.

[source,xml,linenums]
----
<?eclipse version="3.6"?>
<plugin>
  <extension
    point="org.activiti.designer.eclipse.extension.ExportMarshaller">
    <ExportMarshaller
      class="org.acme.export.AcmeExportMarshaller">
    </ExportMarshaller>
  </extension>
  </plugin>
----


[source,java,linenums]
----
public class AcmeExportMarshaller extends AbstractExportMarshaller {
}
----

You are required to implement some methods, such as +getMarshallerName()+ and +getFormatName()+. These methods are used to display options to the user and to show information in progress dialogs, so make sure the descriptions you return reflect the functionality you are implementing.

The bulk of your work is performed in the +doMarshallDiagram()+ method.

If you want to perform a certain validation first, you can invoke the validator directly from your marshaller. You receive a boolean result from the validator, so you know whether validation succeeded. In most cases you won't want to proceed with marshalling the diagram if it's not valid, but you might choose to go ahead anyway or even create a different resource if validation fails.


Once you have all the data you need, you should invoke the +saveResource()+ method to create a file containing your data. You can invoke +saveResource()+ as many times as you wish from a single ExportMarshaller; a marshaller can therefore be used to create more than one output file.

You can construct a filename for your output resource(s) by using the +saveResource()+ method in the +AbstractDiagramWorker+ class. There are a couple of useful variables you can have parsed, allowing you to create filenames such as _original-filename__my-format-name.xml. These variables are described in the Javadocs and defined by the +ExportMarshaller+ interface. You can also use +resolvePlaceholders()+ on a string (e.g. a path) if you want to parse the placeholders yourself. +getURIRelativeToDiagram()+ will invoke this for you.

You should use the progress monitor provided to report your progress back to the user. How to do this is described in link:$$http://www.eclipse.org/articles/Article-Progress-Monitors/article.html$$[this article].
